// TODO: Per style guide, there should be a space before the opening { of a function or block.
//  There should also be a space before the opening ( of a block. for example: if (some logic) {
//  Please update all edited files to follow this pattern.

// TODO: move this array inside of the function. It will not be used anywhere else.
const emptyElements = [
  "<area",
  "<base",
  "<br",
  "<col",
  "<embed",
  "<hr",
  "<img",
  "<input",
  "<keygen",
  "<link",
  "<meta",
  "<param",
  "<source",
  "<track",
  "<wbr"
]

// TODO: Remove test data when ready
let sentence = `<div> <img img tag number 1 ><link link tag number 1><img img tag num 2 >`
let sentence1 = `<img i'm already closed image tag/><img not closed img tag>`

// TODO: This needs to live inside the function. Looks like it is being referenced in both searchForEmptyElements,
//  and isTagClosed. Probably only needs to live in searchForEmptyElements, and can then be passed to isTagClosed.
let strEnd = ""

console.log("END RESULT:........ ", searchForEmptyElement(sentence))
console.log("END RESULT Test 2:........ ",searchForEmptyElement(sentence1))

// TODO: NOTE: This is how a doc comment should be formatted. This format can be auto generated by most IDEs
//  by typing /** and then hitting return. You will need to fill in the description.
/**
 * Parses html string and finds unclosed empty or void elements, and closes them.
 * @param originalStr
 * @returns {string}
 */
function searchForEmptyElement(originalStr){ // TODO: This parameter could be more clearly named. htmlString maybe?
  let str = originalStr  // string to evaluate
  let updatedStr = ""    // string evaluated
  let finalString = ""

   for(let i = 0; i < emptyElements.length; i++){

    let beforeElement = ""
    let afterElement = ""

    //loops through elements, searching for match in string
    let result = emptyElements.some(w => str.includes(emptyElements[i])) //true or false
     // TODO: Above, update the unused 'w' element to be relevant to your arrow function.
     //  In this case it would make the most sense to read like : str => str.includes(emptyElements[i])
     //  This says, for the element str, check that str includes an item from the emptyElements array.
     //  Before it reads, for the element w, check that str includes an item from the emptyElements array.

    let index = originalStr.indexOf(emptyElements[i])  //index of element in original string

    //if found element, separate string so to find next closing tag
    if(result === true){
      let foundElement = emptyElements[i]

      //loops through string, searching for match of found element
      while (index !== -1) {

        let newIndex = str.indexOf(foundElement)  //index of element in new string

        afterElement =  str.substring(newIndex)
        beforeElement = str.substring(0, newIndex)

        // Function to determine if element is closed
        afterElement = isTagClosed(afterElement)

        index = originalStr.indexOf(emptyElements[i], index + 1)   //allows us to check for multiples of same tag

        //set evaluated string
        updatedStr = updatedStr + beforeElement + afterElement

        // set string to evaluate
        str = strEnd
      }
      // set final string after closing element tags
      finalString = updatedStr + str

       // set string to evaluate
      str = finalString

       // reset
      updatedStr = ""
    }
  }

  return finalString
}

// TODO: Does this need to be it's own function? It is only called ones, will only be used in the above function,
//  and does not have any complicated logic. One simple check. Should probably be moved into searchForEmptyElement
function isTagClosed(elementStr){
  //find the corresponding closing tag after the empty element
  let [start, ...end] = elementStr.split('>');
  strEnd = end.join(">");  //separates rest of string, and sets that as next string to evaluate

  // if closing tag is not closed, add "/"
  if(start[start.length - 1] !== "/"){
    return `${start}/>`
  // else return original string
  } else {
    return `${start}>`
  }
}
